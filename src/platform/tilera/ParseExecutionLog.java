package platform.tilera;

import java.io.BufferedReader;


import java.io.DataInputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigInteger;

import output.GanttChart;
import output.GanttChart.Record;

/**
 * Parse the execution log generated by the framework running on Tilera platform.
 * 
 * This is an example of a hardware log file
 * *** Start ***
 * Proc Id : 0 CPU Grid (0, 0) 0
 * Proc Id : 3 CPU Grid (3, 0) 3
 * Proc Id : 2 CPU Grid (2, 0) 2
 * Proc Id : 1 CPU Grid (1, 0) 1
 * 0, 22495687404374461, 22495687404664645, 22495687404409817, 22495687404656400, 22495687404401126, 22495687404651377, 22495687404411696, 22495687404644403,
 * 1, 22495687404778560, 22495687404999386, 22495687404784604, 22495687404988349, 22495687404779792, 22495687404983107, 22495687404765222, 22495687404986552,
 * ....
 * 99, 22495687434776102, 22495687435010964, 22495687434782165, 22495687434999317, 22495687434793363, 22495687434994309, 22495687434769638, 22495687434998148,
 * *** Finished ***
 * 
 * @author Pranav Tendulkar
 */
public class ParseExecutionLog 
{
	/**
	 * Number of processor used
	 */
	private int numProcessors;
	
	/**
	 * Number of Iterations 
	 */
	private int numIterations;
	
	/**
	 * Time log generated by the framework 
	 */
	private long timeLog[][][];	
	
	/**
	 * Plot the gantt chart.
	 * 
	 * @param outputFileName output file name 
	 * @param iterationNumber index of the iteration to be plotted
	 */
	public void plotIteration (String outputFileName, int iterationNumber)
	{
		if(iterationNumber >= numIterations)
			throw new RuntimeException("Number of iterations are only " + numIterations + ". Specify value less than that.");
		
		GanttChart ganttChart = new GanttChart ();
		long minNumber = Long.MAX_VALUE;
		
		for (int i=0;i<numProcessors;i++)
			if (timeLog[iterationNumber][i][0] < minNumber)
				minNumber = timeLog[iterationNumber][i][0];
		
		for (int i=0;i<numProcessors;i++)
		{
			Record record = ganttChart.new Record (i, timeLog[iterationNumber][i][0]-minNumber, timeLog[iterationNumber][i][1]-minNumber, "Proc_" + Integer.toString (i));
			ganttChart.addRecord (record);
		}
		ganttChart.plotChart (outputFileName, -1);
	}
	
	/**
	 * Parse the hardware log file 
	 */
	public void parseHardwareLogFile (int numProcessors, int numIterations, String logFileName)
	{
		this.numProcessors = numProcessors;
		this.numIterations = numIterations;
		
		int count=0;
		BufferedReader br = null;
		try 
		{			
			timeLog = new long [numIterations][numProcessors][2];
			br = new BufferedReader (new InputStreamReader (new DataInputStream (new FileInputStream (logFileName))));
		
			BigInteger timeOffset=null;
			String strLine;
			boolean parsingStarted=false;
			while ((strLine = br.readLine ()) != null)   
			{
				if (strLine.startsWith ("0"))
				{					
					String[] strSplit = strLine.replaceAll ("\\s+","").split (",");
					System.out.println ("Start Time" + strSplit[1]);
					timeOffset = new BigInteger (strSplit[1]);
					System.out.println ("Start Time :: " + timeOffset.toString ());
					parsingStarted=true;
				}
				
				if (parsingStarted && count < numIterations)
				{
					count++;
					String[] strSplit = strLine.replaceAll ("\\s+","").split (",");
					int iteration = Integer.parseInt (strSplit[0]);
					for (int i=0;i<numProcessors;i++)
					{
						BigInteger startTime = new BigInteger (strSplit[2*i+1]);
						BigInteger endTime = new BigInteger (strSplit[2*i+2]);
						timeLog[iteration][i][0] = startTime.subtract (timeOffset).longValue ();
						timeLog[iteration][i][1] = endTime.subtract (timeOffset).longValue ();
					}
				}
			}		
		} catch (FileNotFoundException e) { e.printStackTrace (); } 
		  catch (IOException e) { e.printStackTrace (); }
	}
}
